# 《VueJS 设计与实现》阅读笔记

## 第一篇 框架设计概览

### 第1章 权衡的艺术

* 命令式和声明式这两种范式的差异，其中命令式更加关注过程，而声明式更加关注结果；
* 声明式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗；
* 用原生 JavaScript 操作 DOM 的方法（如document.createElement）、虚拟 DOM 和 innerHTML 三者操作页面的性能，不可以简单地下定论，这与页面大小、变更部分的大小都有关系，与创建页面还是更新页面也有关系；需要结合心智负担、可维护性等因素综合考虑更新策略；
* Vue.js 3 是一个编译时 + 运行时的框架，它在保持灵活性的基础上，还能够通过编译手段分析用户提供的内容，从而进一步提升更新性能。

### 第2章 框架设计的核心要素

* 提供友好的警告信息至关重要；
* 利用 Tree-Shaking 机制，配合构建工具预定义常量的能力，实现线上代码体积的可控性；
* 输出不同格式的资源；
* 提供多种能力或功能，例如：Vue 3 中的选项对象式 API 和组合式 API；
* 可以通过特性开关关闭对应的特性；
* 提供统一的错误处理接口。

### 第3章 Vue.js 3 的设计思路

* Vue.js 是一个声明式的框架。
* 声明式的好处：**直接描述结果，用户不需要关注过程**;
* Vue.js 既模板又支持使用虚拟 DOM 的形式来描述 UI；
* 虚拟 DOM —— 更加灵活；模板 —— 更加直观；
* 渲染器的作用 —— 把虚拟 DOM 对象渲染为真实 DOM 元素。
* 渲染器的工作原理 —— **递归地遍历虚拟 DOM 对象，并调用原生DOM API 来完成真实 DOM 的创建**。
* **组件其实就是一组虚拟 DOM 元素的封装**，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象，但这个对象下必须要有一个函数用来产出组件要渲染的虚拟 DOM。
* Vue.js 的模板会被一个叫作**编译器**的程序**编译为渲染函数**；
* 编译器、渲染器都是 Vue.js 的核心组成部分，它们共同构成一个有机的整体，不同模块之间互相配合，进一步提升框架性能。

## 第二篇 响应系统

### 第4章 响应系统的作用与实现

#### 4.1 响应式数据与副作用函数
#### 4.2 响应式数据的基本实现
#### 4.3 设计一个完善的响应系统
 
* WeakMap 由 target: Map 构成；
* Map 由 key: Set 构成；
* Set 中存储的是依赖集合。

#### 4.4 分支切换与 cleanup
#### 4.5 嵌套的 effect 与 effect 栈
#### 4.6 避免无限递归循环
#### 4.7 调度执行
#### 4.8 计算属性 computed 与 lazy
#### 4.9 watch 的实现原理
#### 4.10 立即执行的 watch 与回调执行时机
#### 4.11 过期的副作用
#### 4.12 总结


### 第5章 非原始值的响应式方案

#### 5.1 理解 Proxy 和 Reflect
#### 5.2 JavaScript 对象及 Proxy 的工作原理
#### 5.3 如何代理 Object
#### 5.4 合理地触发响应
#### 5.5 浅响应与深响应
#### 5.6 只读和浅只读
#### 5.7 代理数组
##### 5.7.1 数组的索引与 length
##### 5.7.2 遍历数组
##### 5.7.3 数组的查找方法
##### 5.7.4 隐式修改数组长度的原型方法

#### 5.8 代理 Set 和 Map

##### 5.8.1 如何代理 Set 和 Map
##### 5.8.2 建立响应联系
##### 5.8.3 避免污染原始数据
##### 5.8.4 处理 forEach
##### 5.8.5 迭代器方法
##### 5.8.6 values 与 keys 方法
#### 5.9 总结


### 第6章 原始值的响应式方案

#### 6.1 引入 ref 的概念
#### 6.2 响应丢失问题
#### 6.3 自动脱 ref
#### 6.4 总结


## 第三篇 渲染器


### 第7章 渲染器的设计

#### 7.1 渲染器与响应系统的结合
#### 7.2 渲染器的基本概念
#### 7.3 自定义渲染器
#### 7.4 总结


### 第8章 挂载与更新

#### 8.1 挂载子节点和元素的属性
#### 8.2 HTML Attributes 与 DOM Properties
#### 8.3 正确地设置元素属性
#### 8.4 class 的处理
#### 8.5 卸载操作
#### 8.6 区分 vnode 的类型
#### 8.7 事件的处理
#### 8.8 事件冒泡与更新时机问题
#### 8.9 更新子节点
#### 8.10 文本节点和注释节点
#### 8.11 Fragment
#### 8.12 总结


### 第9章 简单 Diff 算法

#### 9.1 减少 DOM 操作的性能开销
#### 9.2 DOM 复用与 key 的作用
#### 9.3 找到需要移动的元素
#### 9.4 如何移动元素
#### 9.5 添加新元素
#### 9.6 移除不存在的元素
#### 9.7 总结


### 第10章 双端 Diff 算法

#### 10.1 双端比较的原理
#### 10.2 双端比较的优势
#### 10.3 非理想状况的处理方式
#### 10.4 添加新元素
#### 10.5 移除不存在的元素
#### 10.6 总结


### 第11章 快速 Diff 算法

#### 11.1 相同的前置元素和后置元素
#### 11.2 判断是否需要进行 DOM 移动操作
#### 11.3 如何移动元素
#### 11.4 总结


## 第四篇 组件化


### 第12章 组件的实现原理

#### 12.1 渲染组件
#### 12.2 组件状态与自更新
#### 12.3 组件实例与组件的生命周期
#### 12.4 props 与组件的被动更新
#### 12.5 setup 函数的作用与实现
#### 12.6 组件事件与 emit 的实现
#### 12.7 插槽的工作原理与实现
#### 12.8 注册生命周期
#### 12.9 总结


### 第13章 异步组件与函数式组件

#### 13.1 异步组件要解决的问题
#### 13.2 异步组件的实现原理

##### 13.2.1 封装 defineAsyncComponent 函数
##### 13.2.2 超时与 Error 组件
##### 13.2.3 延迟与 Loading 组件
##### 13.2.4 重试机制

#### 13.3 函数式组件
#### 13.4 总结


### 第14章 内建组件和模块

#### 14.1 KeepAlive 组件的实现原理
##### 14.1.1 组件的激活与失活
##### 14.1.2 include 和 exclude
##### 14.1.3 缓存管理
#### 14.2 Teleport 组件的实现原理

##### 14.2.1 Teleport 组件要解决的问题
##### 14.2.2 实现 Teleport 组件

#### 14.3 Transition 组件的实现原理

##### 14.3.1 原生 DOM 的过渡
##### 14.3.2 实现 Transition 组件
#### 14.4 总结


## 第五篇 编译器


### 第15章 编译器核心技术概览

#### 15.1 模板 DSL 的编译器
#### 15.2 parser 的实现原理与状态机
#### 15.3 构造 AST
#### 15.4 AST 的转换与插件化架构

##### 15.4.1 节点的访问
##### 15.4.2 转换上下文与节点操作
##### 15.4.3 进入与退出

#### 15.5 将模板 AST 转为 JavaScript AST
#### 15.6 代码生成
#### 15.7 总结


### 第16章 解析器

#### 16.1 文本模式及其对解析器的影响
#### 16.2 递归下降算法构造模板 AST
#### 16.3 状态机的开启与停止
#### 16.4 解析标签节点
#### 16.5 解析属性
#### 16.6 解析文本与解码 HTML 实体

##### 16.6.1 解析文本
##### 16.6.2 解码命名字符引用
##### 16.6.3 解码数字字符引用

#### 16.7 解析插值与注释
#### 16.8 总结


### 第17章 编译优化

#### 17.1 动态节点收集与补丁标志
##### 17.1.1 传统 Diff 算法的问题
##### 17.1.2 Block 与 PatchFlags
##### 17.1.3 收集动态节点
##### 17.1.4 渲染器的运行时支持

#### 17.2 Block 树

##### 17.2.1 带有 v-if 指令的节点
##### 17.2.2 带有 v-for 指令的节点
##### 17.2.3 Fragment 的稳定性

#### 17.3 静态提升
#### 17.4 预字符串化
#### 17.5 缓存内联事件处理函数
#### 17.6 v-once
#### 17.7 总结


## 第六篇 服务端渲染


### 第18章 同构渲染

#### 18.1 CSR、SSR 以及同构渲染
#### 18.2 将虚拟 DOM 渲染为 HTML 字符串
#### 18.3 将组件渲染为 HTML 字符串
#### 18.4 客户端激活的原理
#### 18.5 编写同构的代码

##### 18.5.1 组件的生命周期
##### 18.5.2 使用跨平台的 API
##### 18.5.3 只在某一端引入模块
##### 18.5.4 避免交叉请求引起的状态污染
##### 18.5.5 <ClientOnly> 组件

#### 18.6 总结
