### 第1章 权衡的艺术

#### 1.1 命令式和声明式

* 命令式框架 —— **关注过程**，例如 JQuery。
* 声明式框架 —— **关注结果**，例如 Vue.js。

> Vue.js 的内部实现一定是**命令式**的，而暴露给用户的却更加**声明式**。

#### 1.2 性能与可维护性的权衡

声明式代码的性能不优于命令式代码的性能。

如果我们把**直接修改**的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：

* 命令式代码的更新性能消耗 = A
* 声明式代码的更新性能消耗 = B + A

> 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗

框架设计者要做的就是：**在保持可维护性的同时让性能损失最小化**。

#### 1.3 虚拟 DOM 的性能到底如何

虚拟 DOM，就是为了**最小化找出差异**这一步的性能消耗而出现的。

##### innerHTML 和 虚拟DOM

###### innerHTML 创建页面

用一个公式来表达通过 innerHTML 创建页面的性能：
> **HTML 字符串拼接的计算量 + innerHTML 的DOM 计算量**。

使用 innerHTML 更新页面的过程是重新构建 HTML 字符串，再重新设置 DOM 元素的 innerHTML 属性。而重新设置 innerHTML 属性就等价于**销毁所有旧的DOM 元素，再全量创建新的 DOM 元素**。

###### 虚拟 DOM 创建页面

虚拟 DOM 创建页面的过程分为两步：

* 第一步是创建 JavaScript 对象，这个对象可以理解为真实 DOM 的描述；
* 第二步是递归地遍历虚拟 DOM 树并创建真实 DOM。

同样可以用一个公式来表达：

> **创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量**。

虚拟 DOM，它是声明式的，因此**心智负担小，可维护性强**，性能虽然比不上极致优化的原生 JavaScript，但是在保证心智负担和可维护性的前提下相当不错。

#### 1.4 运行时和编译时

当设计一个框架的时候，我们有三种选择：
* 纯运行时的;
* 运行时 + 编译时的 => 代表框架：Vue.js 3;
* 纯编译时的 => 代表框架：Svelte。

#### 1.5 总结

* 命令式和声明式这两种范式的差异，其中命令式更加关注过程，而声明式更加关注结果；
* 声明式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗；
* 用原生 JavaScript 操作 DOM 的方法（如document.createElement）、虚拟 DOM 和 innerHTML 三者操作页面的性能，不可以简单地下定论，这与页面大小、变更部分的大小都有关系，与创建页面还是更新页面也有关系；需要结合心智负担、可维护性等因素综合考虑更新策略；
* Vue.js 3 是一个编译时 + 运行时的框架，它在保持灵活性的基础上，还能够通过编译手段分析用户提供的内容，从而进一步提升更新性能。